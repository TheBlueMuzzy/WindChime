---
phase: 03-audio-engine
plan: 02
type: execute
---

<objective>
Connect QR code detection to audio playback — when a QR code is detected, play its mapped sound.

Purpose: This is the core "wow" moment — point camera at a QR code, hear a sound. Bridges the scanner (Phase 2) and audio engine (03-01).
Output: QR detection triggers mapped sound playback through useAudioEngine.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-audio-engine/03-01-SUMMARY.md

# Key source files:
@src/App.tsx
@src/hooks/useAudioEngine.ts
@src/components/QrScanner.tsx

**Constraining decisions:**
- Sounds bundled in public/sounds/ — pre-load on startup
- 3 cards for v1 — sound mapping JSON maps QR raw values to sound file paths
- Web Audio API via useAudioEngine hook (from 03-01)

**Architecture:**
- Sound mapping: a simple JSON object or TypeScript constant mapping QR code raw values → sound file URLs
- On app mount: load all sounds from the mapping into useAudioEngine
- On QR detection: look up detected rawValue in sound map, call playSound(id)
- For now, ignore re-trigger prevention (Phase 7) — just play on every detection
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sound mapping and pre-load sounds on startup</name>
  <files>src/config/sounds.ts, src/App.tsx</files>
  <action>
1. Create `src/config/sounds.ts` — a TypeScript file that exports a sound mapping:
   ```
   export const SOUND_MAP: Record<string, string> = {
     'chime-1': '/sounds/chime-1.mp3',
     'chime-2': '/sounds/chime-2.mp3',
     'chime-3': '/sounds/chime-3.mp3',
   }
   ```
   The keys are the QR code raw values (what the QR code encodes). The values are the sound file paths in public/.
   Note: Actual sound files don't exist yet (Phase 4 creates them). This just defines the mapping.

2. In App.tsx, add a `useEffect` that runs once on mount:
   - Import SOUND_MAP and useAudioEngine
   - Loop through SOUND_MAP entries, call `loadSound(id, url)` for each
   - Wrap in try/catch — if a sound file doesn't exist yet, log a warning but don't crash
   - Set a `soundsLoaded` state or ref after all loads complete (or all attempted)

3. Update the onScan callback in App.tsx:
   - When a QR code is detected, check if its rawValue exists in SOUND_MAP
   - If yes, call `playSound(rawValue)`
   - If no, ignore (unrecognized QR code)
   - Keep the existing lastDetected display for now (visual feedback that detection works)
  </action>
  <verify>
`npx tsc --noEmit` passes. SOUND_MAP exported from src/config/sounds.ts. App.tsx imports and uses both SOUND_MAP and useAudioEngine.
  </verify>
  <done>
Sound mapping defined. Sounds pre-loaded on mount (gracefully handles missing files). QR detection calls playSound for mapped codes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Generate a test tone and verify end-to-end QR → sound</name>
  <files>scripts/generate-test-tone.js, public/sounds/chime-1.mp3</files>
  <action>
1. Create a simple Node.js script `scripts/generate-test-tone.js` that generates a minimal WAV file:
   - 44100 Hz sample rate, 16-bit mono
   - 0.5 second 440Hz sine wave with a quick fade-out
   - Write to `public/sounds/chime-1.wav` (WAV is simpler to generate than MP3)
   - If WAV generation is too complex without a library, instead: create a tiny valid WAV file manually (the WAV format header is well-documented, ~44 bytes header + PCM data)

2. Update SOUND_MAP to point chime-1 to the WAV file: `'chime-1': '/sounds/chime-1.wav'`

3. Generate a QR code image for testing:
   - Create a simple HTML file or SVG at `test-assets/qr-chime-1.html` that displays a QR code encoding the text "chime-1"
   - Can use a QR code API URL in an img tag: `https://api.qrserver.com/v1/create-qr-code/?data=chime-1&size=200x200`
   - This is for dev testing only — Phase 4 creates the real printable QR cards

4. Clean up any earlier test sound files (e.g., test-tone.mp3 from 03-01 if it exists).
  </action>
  <verify>
Run `node scripts/generate-test-tone.js` — creates WAV file in public/sounds/. Open app in browser, display QR code for "chime-1" on another screen, point phone camera at it — hear the tone.
  </verify>
  <done>
At least one real sound file exists in public/sounds/. QR code "chime-1" triggers audible playback when detected. End-to-end flow works: camera → QR detection → sound playback.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>QR code detection triggering audio playback through Web Audio API</what-built>
  <how-to-verify>
    1. Run: `npm run dev` (starts HTTPS dev server)
    2. On your phone, open the HTTPS URL shown in terminal
    3. On your computer, open test-assets/qr-chime-1.html (or display a QR code encoding "chime-1")
    4. Point your phone camera at the QR code
    5. Confirm: You hear a tone when the QR code is detected
    6. Move camera away and back — tone should play again (no cooldown yet, that's Phase 7)
    7. Note: If no sound plays, tap the screen first (mobile audio unlock — Plan 03-03 fixes this properly)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` succeeds
- [ ] Sound mapping exists in src/config/sounds.ts
- [ ] At least one sound file exists in public/sounds/
- [ ] QR detection triggers playSound call
</verification>

<success_criteria>

- Sound mapping connects QR raw values to sound file URLs
- Sounds pre-load on app startup
- QR detection triggers mapped sound playback
- Human verified: audible playback works on device
</success_criteria>

<output>
After completion, create `.planning/phases/03-audio-engine/03-02-SUMMARY.md`
</output>
