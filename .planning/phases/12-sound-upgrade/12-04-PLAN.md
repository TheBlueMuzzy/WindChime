---
phase: 12-sound-upgrade
plan: 04
type: execute
---

<objective>
Make the app and codes.html fully dynamic — discover sounds at runtime via GitHub API instead of hardcoded lists.

Purpose: Drop new sound files into the repo, push to GitHub, and everything updates automatically. No more editing CHIME_IDS or chime-data.js manually.
Output: App and codes.html both use GitHub Contents API for sound discovery. No hardcoded sound lists anywhere.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-sound-upgrade/12-CONTEXT.md
@.planning/phases/12-sound-upgrade/12-03-SUMMARY.md

**Key files:**
@src/App.tsx (hardcoded CHIME_IDS set — lines 7-12)
@src/hooks/useAudioEngine.ts (no changes needed — already generic)
@public/codes.html (reads from chime-data.js)
@public/chime-data.js (hardcoded list — generated by scripts/generate-chime-list.js)
@vite.config.ts (base: '/WindChime/')

**Constraining decisions:**
- Phase 3: Deferred sound loading — load buffers only after user tap resumes AudioContext
- Phase 8: `import.meta.env.BASE_URL` prefix for public asset paths
- Phase 8: GitHub Pages deploy at thebluemuzzy.github.io/WindChime/

**From CONTEXT.md:**
- GitHub Contents API to list `public/sounds/` at runtime
- Replaces any build-time manifest or hardcoded arrays
- Both app sound loading AND codes.html must be dynamic
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dynamic sound discovery to the React app</name>
  <files>src/App.tsx, src/hooks/useChimeList.ts</files>
  <action>
Create a new hook `src/hooks/useChimeList.ts` that:

1. Calls GitHub Contents API on mount:
   `https://api.github.com/repos/TheBlueMuzzy/WindChime/contents/public/sounds`
   (This is a public repo — no auth needed)
2. Parses the response to extract filenames matching `Chime_*.mp3`
3. Strips the `.mp3` extension to get chime IDs
4. Sorts them naturally (Chime_001 before Chime_010)
5. Returns `{ chimeIds: string[], loading: boolean, error: string | null }`
6. **Fallback:** If the API call fails (rate limit, offline, etc.), fall back to a hardcoded list or try fetching a local manifest. For resilience, generate a `public/sounds/manifest.json` during build (via `generate-chime-list.js`) as fallback. Try GitHub API first, fall back to manifest.

In `src/App.tsx`:
1. Remove the hardcoded `CHIME_IDS` constant (lines 7-12)
2. Use the new `useChimeList()` hook to get chime IDs
3. Replace all references to `CHIME_IDS` with the dynamic list
4. The sound loading useEffect already iterates over a list — just swap the source
5. The onScan handler validation (`CHIME_IDS.has(v)`) needs to use a Set built from the dynamic list
6. Show a small "Loading sounds..." state while the list is being fetched (before audio unlock)

**Important:** The GitHub API returns the contents of the deployed `public/sounds/` directory. After a deploy, new files appear automatically. The BASE_URL prefix for sound file URLs stays the same — `${import.meta.env.BASE_URL}sounds/${id}.mp3`.

**Also important:** The GitHub API has a 60 requests/hour rate limit for unauthenticated requests. The manifest.json fallback ensures the app always works even if rate-limited.
  </action>
  <verify>npm run build succeeds. Dev server starts and the app loads chime list from GitHub API (check network tab) or falls back to manifest.</verify>
  <done>App discovers sounds dynamically at runtime. No hardcoded CHIME_IDS in source. Fallback manifest works if API is unavailable.</done>
</task>

<task type="auto">
  <name>Task 2: Make codes.html dynamic via GitHub API</name>
  <files>public/codes.html</files>
  <action>
Update `public/codes.html` to fetch its chime list from GitHub API instead of `chime-data.js`:

1. Remove the `<script src="chime-data.js"></script>` tag
2. Add an async init function that:
   - Fetches `https://api.github.com/repos/TheBlueMuzzy/WindChime/contents/public/sounds`
   - Parses response to extract `Chime_*.mp3` filenames → strip to IDs
   - Falls back to fetching `sounds/manifest.json` (relative URL) if API fails
   - Populates `ALL_CHIMES` array
   - Calls `renderSlots(pickRandom3())` and `renderGrid()`
3. Show a "Loading chimes..." message while fetching
4. Keep all existing UI logic (randomize, hide/show toggle, QR generation via qrserver.com API)

**Note:** `chime-data.js` becomes ONLY a build-time fallback. It can still be generated by `npm run update-chimes` but is no longer the primary data source for codes.html.

**Also update** `scripts/generate-chime-list.js` to ALSO write `public/sounds/manifest.json` (a plain JSON array of chime IDs) alongside `chime-data.js`. This serves as the offline fallback for both the app and codes.html.
  </action>
  <verify>Open codes.html in browser — QR codes render for all 100 chimes. Network tab shows GitHub API call (or manifest fallback).</verify>
  <done>codes.html discovers chimes dynamically. No dependency on chime-data.js at runtime. manifest.json fallback works.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds with no TypeScript errors
- [ ] App loads chime list from GitHub API in production
- [ ] App falls back to manifest.json if API unavailable
- [ ] codes.html loads chime list dynamically
- [ ] No hardcoded chime IDs remain in source (except manifest as generated fallback)
- [ ] `npm run update-chimes` generates both `chime-data.js` and `manifest.json`
</verification>

<success_criteria>

- Both app and codes.html use dynamic sound discovery
- GitHub API is primary source, manifest.json is fallback
- No hardcoded CHIME_IDS in React source
- Build passes cleanly
- Ready for Plan 05 (deploy + e2e verification)
</success_criteria>

<output>
After completion, create `.planning/phases/12-sound-upgrade/12-04-SUMMARY.md`
</output>
